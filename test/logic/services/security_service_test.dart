import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:phf/data/repositories/app_meta_repository.dart';
import 'package:phf/logic/services/security_service.dart';
import 'package:local_auth/local_auth.dart';

@GenerateNiceMocks([
  MockSpec<FlutterSecureStorage>(),
  MockSpec<AppMetaRepository>(),
  MockSpec<LocalAuthentication>(),
])
import 'security_service_test.mocks.dart';

void main() {
  late SecurityService service;
  late MockFlutterSecureStorage mockStorage;
  late MockAppMetaRepository mockMetaRepo;
  late MockLocalAuthentication mockLocalAuth;

  setUp(() {
    mockStorage = MockFlutterSecureStorage();
    mockMetaRepo = MockAppMetaRepository();
    mockLocalAuth = MockLocalAuthentication();
    service = SecurityService(
      secureStorage: mockStorage,
      metaRepo: mockMetaRepo,
      localAuth: mockLocalAuth,
    );
  });

  group('SecurityService', () {
    test('setPin hashes pin and updates lock status', () async {
      const pin = '123456';

      await service.setPin(pin);

      verify(mockStorage.write(
        key: 'user_pin_hash',
        value: anyNamed('value'),
      )).called(1);

      verify(mockMetaRepo.setHasLock(true)).called(1);
    });

    test('validatePin returns true for correct pin', () async {
      const pin = '123456';
      // Capture the hash generated by setPin logic or simulate it manually if needed,
      // but simpler is to rely on implementation details for unit test consistency.
      // Re-using hash logic from service (or duplicate here):
      // pin '123456' sha256 -> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92

      when(mockStorage.read(key: 'user_pin_hash')).thenAnswer(
        (_) async =>
            '8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',
      );

      final result = await service.validatePin(pin);
      expect(result, isTrue);
    });

    test('validatePin returns false for incorrect pin', () async {
      when(mockStorage.read(key: 'user_pin_hash')).thenAnswer(
        (_) async => 'stored_hash',
      );

      final result = await service.validatePin('000000');
      expect(result, isFalse);
    });

    test('enableBiometrics writes to storage on success', () async {
      when(mockLocalAuth.authenticate(
        localizedReason: anyNamed('localizedReason'),
        biometricOnly: anyNamed('biometricOnly'),
      )).thenAnswer((_) async => true);

      final result = await service.enableBiometrics();

      expect(result, isTrue);
      verify(mockStorage.write(key: 'biometrics_enabled', value: 'true'))
          .called(1);
    });
  });
}
